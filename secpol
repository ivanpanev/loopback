Here's my error:

{
  "changed": true,
  "stdout": "[8989898] Starting script execution.\nGon Get API Key.",
  "stderr": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/connection.py\", line 174, in _new_conn\n    conn = connection.create_connection(\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/util/connection.py\", line 95, in create_connection\n    raise err\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/util/connection.py\", line 85, in create_connection\n    sock.connect(sa)\nOSError: [Errno 101] Network is unreachable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py\", line 715, in urlopen\n    httplib_response = self._make_request(\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py\", line 404, in _make_request\n    self._validate_conn(conn)\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py\", line 1060, in _validate_conn\n    conn.connect()\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/connection.py\", line 363, in connect\n    self.sock = conn = self._new_conn()\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/connection.py\", line 186, in _new_conn\n    raise NewConnectionError(\nurllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPSConnection object at 0x7f03318b40d0>: Failed to establish a new connection: [Errno 101] Network is unreachable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.9/site-packages/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py\", line 801, in urlopen\n    retries = retries.increment(\n  File \"/usr/local/lib/python3.9/site-packages/urllib3/util/retry.py\", line 594, in increment\n    raise MaxRetryError(_pool, url, error or ResponseError(cause))\nurllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='100.66.31.9', port=443): Max retries exceeded with url: /api/?type=keygen&user=t3-admin&password=Px3Kx%5B8SxN (Caused by NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f03318b40d0>: Failed to establish a new connection: [Errno 101] Network is unreachable'))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/palo_scripts/main.py\", line 155, in <module>\n    main()\n  File \"/tmp/palo_scripts/main.py\", line 83, in main\n    api_key = get_api_key(palo_ip, username, password)\n  File \"/tmp/palo_scripts/main.py\", line 54, in get_api_key\n    resp = requests.get(url, verify=False, timeout=10, proxies=proxies_off)\n  File \"/usr/local/lib/python3.9/site-packages/requests/api.py\", line 73, in get\n    return request(\"get\", url, params=params, **kwargs)\n  File \"/usr/local/lib/python3.9/site-packages/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n  File \"/usr/local/lib/python3.9/site-packages/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n  File \"/usr/local/lib/python3.9/site-packages/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n  File \"/usr/local/lib/python3.9/site-packages/requests/adapters.py\", line 700, in send\n    raise ConnectionError(e, request=request)\nrequests.exceptions.ConnectionError: HTTPSConnectionPool(host='100.66.31.9', port=443): Max retries exceeded with url: /api/?type=keygen&user=t3-admin&password=Px3Kx%5B8SxN (Caused by NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f03318b40d0>: Failed to establish a new connection: [Errno 101] Network is unreachable'))",
  "rc": 1,
  "cmd": [
    "python3",
    "/tmp/palo_scripts/main.py"
  ],
  "start": "2025-04-29 10:19:57.000940",
  "end": "2025-04-29 10:20:01.211327",
  "delta": "0:00:04.210387",
  "msg": "non-zero return code",
  "invocation": {
    "module_args": {
      "_raw_params": "python3 /tmp/palo_scripts/main.py\n",
      "_uses_shell": false,
      "stdin_add_newline": true,
      "strip_empty_ends": true,
      "argv": null,
      "chdir": null,
      "executable": null,
      "creates": null,
      "removes": null,
      "stdin": null
    }
  },
  "stdout_lines": [
    "[8989898] Starting script execution.",
    "Gon Get API Key."
  ],
  "stderr_lines": [
    "Traceback (most recent call last):",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/connection.py\", line 174, in _new_conn",
    "    conn = connection.create_connection(",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/util/connection.py\", line 95, in create_connection",
    "    raise err",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/util/connection.py\", line 85, in create_connection",
    "    sock.connect(sa)",
    "OSError: [Errno 101] Network is unreachable",
    "",
    "During handling of the above exception, another exception occurred:",
    "",
    "Traceback (most recent call last):",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py\", line 715, in urlopen",
    "    httplib_response = self._make_request(",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py\", line 404, in _make_request",
    "    self._validate_conn(conn)",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py\", line 1060, in _validate_conn",
    "    conn.connect()",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/connection.py\", line 363, in connect",
    "    self.sock = conn = self._new_conn()",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/connection.py\", line 186, in _new_conn",
    "    raise NewConnectionError(",
    "urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPSConnection object at 0x7f03318b40d0>: Failed to establish a new connection: [Errno 101] Network is unreachable",
    "",
    "During handling of the above exception, another exception occurred:",
    "",
    "Traceback (most recent call last):",
    "  File \"/usr/local/lib/python3.9/site-packages/requests/adapters.py\", line 667, in send",
    "    resp = conn.urlopen(",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py\", line 801, in urlopen",
    "    retries = retries.increment(",
    "  File \"/usr/local/lib/python3.9/site-packages/urllib3/util/retry.py\", line 594, in increment",
    "    raise MaxRetryError(_pool, url, error or ResponseError(cause))",
    "urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='100.66.31.9', port=443): Max retries exceeded with url: /api/?type=keygen&user=t3-admin&password=Px3Kx%5B8SxN (Caused by NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f03318b40d0>: Failed to establish a new connection: [Errno 101] Network is unreachable'))",
    "",
    "During handling of the above exception, another exception occurred:",
    "",
    "Traceback (most recent call last):",
    "  File \"/tmp/palo_scripts/main.py\", line 155, in <module>",
    "    main()",
    "  File \"/tmp/palo_scripts/main.py\", line 83, in main",
    "    api_key = get_api_key(palo_ip, username, password)",
    "  File \"/tmp/palo_scripts/main.py\", line 54, in get_api_key",
    "    resp = requests.get(url, verify=False, timeout=10, proxies=proxies_off)",
    "  File \"/usr/local/lib/python3.9/site-packages/requests/api.py\", line 73, in get",
    "    return request(\"get\", url, params=params, **kwargs)",
    "  File \"/usr/local/lib/python3.9/site-packages/requests/api.py\", line 59, in request",
    "    return session.request(method=method, url=url, **kwargs)",
    "  File \"/usr/local/lib/python3.9/site-packages/requests/sessions.py\", line 589, in request",
    "    resp = self.send(prep, **send_kwargs)",
    "  File \"/usr/local/lib/python3.9/site-packages/requests/sessions.py\", line 703, in send",
    "    r = adapter.send(request, **kwargs)",
    "  File \"/usr/local/lib/python3.9/site-packages/requests/adapters.py\", line 700, in send",
    "    raise ConnectionError(e, request=request)",
    "requests.exceptions.ConnectionError: HTTPSConnectionPool(host='100.66.31.9', port=443): Max retries exceeded with url: /api/?type=keygen&user=t3-admin&password=Px3Kx%5B8SxN (Caused by NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f03318b40d0>: Failed to establish a new connection: [Errno 101] Network is unreachable'))"
  ],
  "_ansible_no_log": false,
  "_ansible_delegated_vars": {
    "ansible_host": "10.16.2.22",
    "ansible_port": null,
    "ansible_user": "tier3.global.ip"
  }
}


here's my main playbook:

---
- name: Lookup device in NetBox and update PrimaryIP
  hosts: localhost
  gather_facts: no
  connection: local
  vars:
    netbox_base: "https://netbox.gt-t.net/api/"
    scripts_dir: "scripts/"

  tasks:
  - name: Get vault passwords
    set_fact:
      vault: "{{ lookup('hashi_vault', 'secret=ansible/data/tss') }}"
    no_log: true

  - name: Set NetBox token as a fact
    set_fact:
      netbox_token: "{{ vault.netbox_soc_token }}"
    no_log: true

  # - name: Show incoming hostvars/extra_vars
  #   debug:
  #     var: hostvars[inventory_hostname]
  #   when: show_extra_vars | default(true)

  - name: Determine current GNID once
    set_fact:
      current_gnid: >-
        {{
            (hostvars[inventory_hostname].extra_vars.RequestDetails.GNID
               if (hostvars[inventory_hostname].extra_vars is defined
                   and hostvars[inventory_hostname].extra_vars.RequestDetails is defined)
               else RequestDetails.GNID)
        }}

  - name: Lookup PaloAlto firewall details in NetBox
    include_tasks: include_tasks/netbox_palo_fw_lookup.yml

  - name: Bail if no firewall entry was found
    fail:
      msg: "No device found with GNID {{ current_gnid }}"
    when: nb_primary_ip is not defined

  - name: Ensure extra_vars dict exists
    set_fact:
      extra_vars: {}
    when: extra_vars is not defined

  - name: Inject NetBox data into extra_vars.RequestDetails
    set_fact:
      extra_vars: >-
        {{ extra_vars
           | combine(
               {'RequestDetails':
                 (extra_vars.RequestDetails | default({}))
                 | combine({
                     'PrimaryIP'   : nb_primary_ip,
                     'role_id'     : nb_role_id,
                     'jumphost'    : nb_jumphost,
                     'panorama_ip' : nb_panorama_ip
                   })
               },
               recursive=true
             )
        }}

  - name: Show updated extra_vars
    debug:
      var: hostvars[inventory_hostname].extra_vars
    when:
      - show_extra_vars | default(true)
      - nb_primary_ip is defined

  - name: Serialise extra_vars for the Python script
    set_fact:
      extra_vars_json: "{{ extra_vars | to_json }}"
    no_log: true
  
  - name: Serialise extra_vars for the Python script
    set_fact:
      extra_vars_json: "{{ extra_vars | to_json }}"
    no_log: true

  # - name: Verify TCP 443 is open from {{ nb_jumphost }}
  #   wait_for:
  #     host: "{{ nb_primary_ip }}"
  #     port: 443
  #     timeout: 5
  #     state: started
  #   delegate_to: 10.160.2.22
  
  # - name: Palo-Alto API probe – keygen
  #   uri:
  #     url: "https://{{ nb_primary_ip }}/api/"
  #     validate_certs: no
  #     method: GET
  #     return_content: yes
  #     status_code: 200
  #     params:
  #       type: keygen
  #       user: "t3-admin"
  #       password: "Px3Kx[8SxN"
  #   delegate_to: 10.160.2.22
  #   register: api_ping
  #   failed_when: "'<response status=\"success\"' not in api_ping.content"

#===========================================

  # - name: Ensure script folder exists on {{ nb_jumphost }}
  #   file:
  #     path: /tmp/palo_scripts
  #     state: directory
  #     mode: '0755'
  #   delegate_to: "{{ nb_jumphost }}"
  #   when: nb_jumphost != 'localhost'

  # - name: Copy Python helper files to {{ nb_jumphost }}
  #   copy:
  #     src: "{{ item }}"
  #     dest: "/tmp/palo_scripts/{{ item | basename }}"
  #     mode: '0755'
  #   loop: "{{ lookup('fileglob', scripts_dir + '/*.py', wantlist=True) }}"
  #   delegate_to: "{{ nb_jumphost }}"
  #   when: nb_jumphost != 'localhost'

  # - name: Run main.py on {{ nb_jumphost }}
  #   command: >
  #     python3 {{
  #       (nb_jumphost == 'localhost')
  #       | ternary(scripts_dir + '/main.py', '/tmp/palo_scripts/main.py')
  #     }}
  #   delegate_to: "{{ nb_jumphost }}"
  #   environment:
  #     EXTRA_VARS: "{{ extra_vars_json }}"
  #   register: python_result

#===========================================

  # - name: FALSE Show effective UID and routing table (debug)
  #   command: |
  #     sh -c 'id -u && ip route get {{ nb_primary_ip }}'
  #   delegate_to: "{{ nb_jumphost }}"
  #   become: false

  # - name: TRUE Show effective UID and routing table (debug)
  #   command: |
  #     sh -c 'id -u && ip route get {{ nb_primary_ip }}'
  #   delegate_to: "{{ nb_jumphost }}"
  #   become: true

#+=====================================

  - name: Ensure script folder exists on {{ nb_jumphost }}
    file:
      path: /tmp/palo_scripts
      state: directory
      mode: '0755'
    become: false
    delegate_to: "{{ nb_jumphost }}"
    when: nb_jumphost != 'localhost'

  ###########################################################################
  # 7a. Copy helpers without sudo         (only when jumphost is remote)    #
  ###########################################################################
  - name: Copy Python helper files to {{ nb_jumphost }}
    copy:
      src: "{{ item }}"
      dest: "/tmp/palo_scripts/{{ item | basename }}"
      mode: '0755'
    loop: "{{ lookup('fileglob', scripts_dir + '/*.py', wantlist=True) }}"
    delegate_to: "{{ nb_jumphost }}"
    become: false                  # <─── force NO privilege escalation
    when: nb_jumphost != 'localhost'
  
  ###########################################################################
  # 7b. Run main.py exactly like your manual test                           #
  ###########################################################################
  - name: Run main.py on {{ nb_jumphost }}
    command: >
      python3 {{
        (nb_jumphost == 'localhost')
        | ternary(scripts_dir + '/main.py', '/tmp/palo_scripts/main.py')
      }}
    delegate_to: "{{ nb_jumphost }}"
    become: false
    environment:
      EXTRA_VARS: "{{ extra_vars_json }}"
      HTTP_PROXY: ""
      HTTPS_PROXY: ""
      NO_PROXY: "{{ nb_primary_ip }}"
    register: python_result
#+========================================


  # - name: Run main.py
  #   ansible.builtin.script:
  #     cmd: main.py
  #     executable: /usr/bin/python3
  #   register: logNewNetboxDataVariable
  #   changed_when: false
  #   become: false
  #   delegate_to: 10.160.2.22

  - name: Show script stdout
    debug:
      var: python_result.stdout_lines
    when: show_extra_vars | default(true)




Here's my main.py function;



import gttPaloUtilities
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
import sys
import time
import json
import itertools
from functools import partial
from global_logger import logger
import requests
import urllib3
import urllib
import xml.etree.ElementTree as ET
import re

# Thread-safe ID generator for ID-ing each sub-task within the ticket.
object_id_generator = itertools.count(1)
rule_id_generator = itertools.count(1)

def addr_object_change_handler(palo_ip, api_key, ticket_id, ticket_subtask_id, addrObjectChange):
    print(f"[{ticket_id}-{ticket_subtask_id}] Processing address object change.")
    logger.debug(f"Initiating object configuration: {ticket_id} subtask {ticket_subtask_id}!")
    if addrObjectChange['ChangeType'] == 'Add':
        object_creation_success_flag = gttPaloUtilities.configure_address_object_add(palo_ip=palo_ip, api_key=api_key, addr_object_params=addrObjectChange, ticket_subtask_id=ticket_subtask_id)
        if object_creation_success_flag:
            print(f"[{ticket_id}-{ticket_subtask_id}] Object {addrObjectChange['ObjectName']} configured successfully!")
            logger.debug(f"Successfully executed ticket {ticket_id} subtask {ticket_subtask_id}!")
        else:
            print(f"[{ticket_id}-{ticket_subtask_id}] Object {addrObjectChange['ObjectName']} configuration failed!")
            logger.warning(f"Failed to execute ticket {ticket_id} subtask {ticket_subtask_id}!")

def security_rule_change_handler(palo_ip, api_key, ticket_id, ticket_subtask_id, ruleChange, prefetched_data):
    print(f"[{ticket_id}-{ticket_subtask_id}] Processing security rule change.")
    logger.debug(f"Initiating security rule configuration: {ticket_id} subtask {ticket_subtask_id}!")
    if ruleChange['ChangeType'] == 'Add':
        rule_creation_success_flag = gttPaloUtilities.configure_security_policy_add(palo_ip=palo_ip, api_key=api_key, rule_params=ruleChange, prefetched_data=prefetched_data, ticket_subtask_id=ticket_subtask_id)
        if rule_creation_success_flag:
            print(f"[{ticket_id}-{ticket_subtask_id}] Security rule {ruleChange['RuleName']} configured successfully!")
            logger.debug(f"Successfully executed ticket {ticket_id} subtask {ticket_subtask_id}!")
        else:
            print(f"[{ticket_id}-{ticket_subtask_id}] Security rule {ruleChange['RuleName']} configuration failed!")
            logger.warning(f"Failed to execute ticket {ticket_id} subtask {ticket_subtask_id}!")

def get_api_key(palo_ip, username, password):
    base = f"https://{palo_ip}/api/"
    url  = base + "?" + urllib.parse.urlencode({
        "type": "keygen",
        "user": username,
        "password": password
    })

    proxies_off = {"http": None, "https": None}

    resp = requests.get(url, verify=False, timeout=10, proxies=proxies_off)
    resp.raise_for_status()

    root = ET.fromstring(resp.content)
    key  = root.findtext(".//key")
    if not key:
        raise Exception("key element missing in response")
    return key

def main():
    # Load dummy input data
    sample_input_file = "sampleInputs.json"
    with open(sample_input_file, "r") as file:
        sample_input = json.load(file)

    ticket_id = sample_input["RequestDetails"]["TicketNumber"]
    palo_ip = sample_input["RequestDetails"]["PrimaryIP"]

    logger.set_context(ticket_id=ticket_id, palo_ip=palo_ip)

    username = 't3-admin'
    password = 'Px3Kx[8SxN'

    total_start = time.perf_counter()
    print(f"[{ticket_id}] Starting script execution.")
    print("Gon Get API Key.")

    # Generate and store API token
    startTime = time.perf_counter()
    api_key = get_api_key(palo_ip, username, password)
    elapsed = time.perf_counter() - startTime
    print(f"[{ticket_id}] Get API Key completed in {elapsed:.2f} seconds.")

    #Verify if device is in a High-Availability cluster and if so, ensure changes are being performed on the 'active' cluster member. End script execution if in a 'bad' HA state.
    startTime = time.perf_counter()
    haState, haPeerIp = gttPaloUtilities.get_ha_status_and_peer_ip(palo_ip, api_key)
    if haState == 'active' or haState == 'active-primary':
        pass
    elif haState == 'passive' or haState == 'active-secondary':
        palo_ip = haPeerIp
    elif haState == 'suspended' or haState == 'tentative' or haState == 'non-functional' or haState == 'initial':
        print("BAD HA STATE. Terminating script.")
        sys.exit()
    elapsed = time.perf_counter() - startTime
    print(f"[{ticket_id}] HA check completed in {elapsed:.2f} seconds.")

    # Split changes into lists by type
    addrObjectChanges = [change for change in sample_input["Changes"] if change["ChangeCategory"] == "AddressObject"]
    ruleChanges = [change for change in sample_input["Changes"] if change["ChangeCategory"] == "SecurityRule"]

    # Handle each address object change in parallel
    startTime = time.perf_counter()
    if addrObjectChanges:
        with ThreadPoolExecutor(max_workers=5) as objectExecutor: 
            futures = [objectExecutor.submit(addr_object_change_handler, palo_ip, api_key, ticket_id, f"OBJ-{next(object_id_generator)}", addr_change) for addr_change in addrObjectChanges]
            for future in as_completed(futures):
                future.result()
    elapsed = time.perf_counter() - startTime
    print(f"[{ticket_id}] Address objects configured in {elapsed:.2f} seconds.")

    # Prefetch firewall data for logical validations of security rules in parallel
    startTime = time.perf_counter()
    if ruleChanges:
        with ThreadPoolExecutor(max_workers=6) as prefetchExecutor: 
            futures = {
                prefetchExecutor.submit(gttPaloUtilities.get_all_interfaces, palo_ip, api_key): 'existingInterfaces',
                prefetchExecutor.submit(gttPaloUtilities.get_all_security_rules, palo_ip, api_key): 'existingSecurityPolicy',
                prefetchExecutor.submit(gttPaloUtilities.get_all_service_objects, palo_ip, api_key): 'existingServiceObjects',
                prefetchExecutor.submit(gttPaloUtilities.get_all_address_objects, palo_ip, api_key): 'existingAddressObjects',
                prefetchExecutor.submit(gttPaloUtilities.get_all_address_group_objects, palo_ip, api_key): 'existingAddressGroupObjects',
                prefetchExecutor.submit(gttPaloUtilities.get_all_regions, palo_ip, api_key): 'existingRegions'
            }
        
        prefetched_data = {}
        for future in as_completed(futures):
            task_name = futures[future]
            try:
                prefetched_data[task_name] = future.result()
            except Exceptions as e:
                print(f"Error prefetching existing configuration details {task_name}: {e}")

    elapsed = time.perf_counter() - startTime
    print(f"[{ticket_id}] Prefetched firewall data for logical validations in {elapsed:.2f} seconds.")
    print(f"[{ticket_id}] Prefetch data: {prefetched_data}")

    # Handle each security rule change in parallel
    startTime = time.perf_counter()
    if ruleChanges:
        with ThreadPoolExecutor(max_workers=5) as ruleExecutor:
            futures = [ruleExecutor.submit(security_rule_change_handler, palo_ip, api_key, ticket_id, f"SEC-RULE-{next(rule_id_generator)}", rule_change, prefetched_data) for rule_change in ruleChanges]
            for future in as_completed(futures):
                future.result()
    elapsed = time.perf_counter() - startTime
    print(f"[{ticket_id}] Security rules configured in {elapsed:.2f} seconds.")

    total_elapsed = time.perf_counter() - total_start
    print(f"[{ticket_id}] Full execution completed in {total_elapsed:.2f} seconds.")

# if __name__ == "__main__":
#     main()

main()
